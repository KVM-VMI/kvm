From f834c9373c628faf9e7494e7615f390d338b744b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Adalbert=20Laz=C4=83r?= <alazar@bitdefender>
Date: Wed, 8 Dec 2017 03:36:24 +0200
Subject: [PATCH] add kvmi support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Add the new 'introspection' object with two required options:
 - chardev: the socket connected to the introspection tool
 - key: the key to validate the introspection tool
Add the 'cid' option to chardev/socket object (vsock).
Add the 'fd' class property to chardev/socket.
Add the 'introspection' option to accel/kvm.

The introspector is started with:
	-device vhost-vsock-pci,id=vhost-vsock-pci0,guest-cid=3

The introspected VM is started with:
	-chardev socket,id=chardev0,cid=3,port=1234 \
	-object secret,id=key0,data=some \
	-object introspection,id=kvmi,chardev=chardev0,key=key0 \
	-accel kvm,introspection=kvmi

The 'secret' object is not used yet, but required :)

Signed-off-by: Adalbert LazÄƒr <alazar@bitdefender.com>
---
 accel/kvm/Makefile.objs           |   1 +
 accel/kvm/kvm-all.c               |  47 +++++++++++
 accel/kvm/vm-introspection.c      | 169 ++++++++++++++++++++++++++++++++++++++
 chardev/char-socket.c             |  30 ++++++-
 chardev/char.c                    |   3 +
 cpus.c                            |   1 +
 include/sysemu/kvm.h              |   7 ++
 include/sysemu/vm-introspection.h |  53 ++++++++++++
 linux-headers/linux/kvm.h         |   8 ++
 vl.c                              |   9 ++
 10 files changed, 326 insertions(+), 2 deletions(-)
 create mode 100644 accel/kvm/vm-introspection.c
 create mode 100644 include/sysemu/vm-introspection.h

diff --git a/accel/kvm/Makefile.objs b/accel/kvm/Makefile.objs
index 85351e7de7..e014aa6c2c 100644
--- a/accel/kvm/Makefile.objs
+++ b/accel/kvm/Makefile.objs
@@ -1 +1,2 @@
 obj-$(CONFIG_KVM) += kvm-all.o
+obj-$(CONFIG_KVM) += vm-introspection.o
diff --git a/accel/kvm/kvm-all.c b/accel/kvm/kvm-all.c
index f290f487a5..28ce3a0efa 100644
--- a/accel/kvm/kvm-all.c
+++ b/accel/kvm/kvm-all.c
@@ -38,6 +38,7 @@
 #include "qemu/event_notifier.h"
 #include "trace.h"
 #include "hw/irq.h"
+#include "sysemu/vm-introspection.h"
 
 #include "hw/boards.h"
 
@@ -103,6 +104,7 @@ struct KVMState
 #endif
     KVMMemoryListener memory_listener;
     QLIST_HEAD(, KVMParkedVcpu) kvm_parked_vcpus;
+    const char *introspected_id;
 };
 
 KVMState *kvm_state;
@@ -131,6 +133,51 @@ static const KVMCapabilityInfo kvm_required_capabilites[] = {
     KVM_CAP_LAST_INFO
 };
 
+static void connect_introspection(const char *id, Error **errp)
+{
+    KVMState *s;
+    int ret;
+    struct kvm_introspection h = {};
+    Object *obj;
+
+    /* TODO: how do we reconnect? */
+    /* TODO: proper capabilities. */
+
+    obj = object_resolve_path_component(object_get_objects_root(), id);
+    if (!obj) {
+        error_setg(errp, "introspection object '%s' not found", id);
+        return;
+    }
+
+    h.fd = vm_introspection_fd(obj, &h.commands, &h.events, errp);
+
+    if (h.fd == -1) {
+        error_setg(errp, "introspection handshake failed");
+        return;
+    }
+
+    s = KVM_STATE(current_machine->accelerator);
+
+    ret = kvm_vm_ioctl(s, KVM_INTROSPECTION, &h);
+    close(h.fd);
+
+    if (ret < 0) {
+        error_setg(errp, "handing over the introspection fd failed: %d",
+                   -errno);
+    }
+}
+
+void kvm_configure(QemuOpts *opts, Error **errp)
+{
+    KVMState *s = KVM_STATE(current_machine->accelerator);
+    const char *i = qemu_opt_get(opts, "introspection");
+
+    if (i) {
+        s->introspected_id = i;
+        connect_introspection(i, errp);
+    }
+}
+
 int kvm_get_max_memslots(void)
 {
     KVMState *s = KVM_STATE(current_machine->accelerator);
diff --git a/accel/kvm/vm-introspection.c b/accel/kvm/vm-introspection.c
new file mode 100644
index 0000000000..20b46cb195
--- /dev/null
+++ b/accel/kvm/vm-introspection.c
@@ -0,0 +1,169 @@
+/*
+ * VM Introspection
+ *
+ * Copyright (C) 2017 Bitdefender S.R.L.
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ */
+
+#include "qemu/osdep.h"
+#include "chardev/char.h"
+#include "chardev/char-fe.h"
+#include "qapi/error.h"
+#include "qemu/error-report.h"
+#include "qom/object.h"
+#include "qom/object_interfaces.h"
+#include "sysemu/sysemu.h"
+#include "sysemu/vm-introspection.h"
+
+typedef struct VMIntrospection {
+    Object parent_obj;
+    char *chardevid;
+    char *keyid;
+    /* allow, deny commands and events */
+} VMIntrospection;
+
+#define TYPE_VM_INTROSPECTION "introspection"
+
+#define VM_INTROSPECTION(obj)                                                  \
+    OBJECT_CHECK(VMIntrospection, (obj), TYPE_VM_INTROSPECTION)
+
+static void complete(UserCreatable *uc, Error **errp)
+{
+    VMIntrospection *i = VM_INTROSPECTION(uc);
+
+    if (!i->chardevid || !i->keyid) {
+        error_setg(errp, "introspection needs 'chardev' ,"
+                         "'key' property set");
+        return;
+    }
+}
+
+static void prop_set_chardev(Object *obj, const char *value, Error **errp)
+{
+    VMIntrospection *i = VM_INTROSPECTION(obj);
+
+    g_free(i->chardevid);
+    i->chardevid = g_strdup(value);
+}
+
+static void prop_set_key(Object *obj, const char *value, Error **errp)
+{
+    VMIntrospection *i = VM_INTROSPECTION(obj);
+
+    g_free(i->keyid);
+    i->keyid = g_strdup(value);
+}
+
+static void class_init(ObjectClass *oc, void *data)
+{
+    USER_CREATABLE_CLASS(oc)->complete = complete;
+}
+
+static void instance_init(Object *obj)
+{
+    object_property_add_str(obj, "key", NULL, prop_set_key, NULL);
+    object_property_add_str(obj, "chardev", NULL, prop_set_chardev, NULL);
+}
+
+static void instance_finalize(Object *obj)
+{
+    VMIntrospection *i = VM_INTROSPECTION(obj);
+
+    g_free(i->chardevid);
+    g_free(i->keyid);
+}
+
+static const TypeInfo info = {
+    .name              = TYPE_VM_INTROSPECTION,
+    .parent            = TYPE_OBJECT,
+    .class_init        = class_init,
+    .instance_size     = sizeof(VMIntrospection),
+    .instance_finalize = instance_finalize,
+    .instance_init     = instance_init,
+    .interfaces        = (InterfaceInfo[]){
+        {TYPE_USER_CREATABLE},
+        {}
+    }
+};
+
+static void register_types(void)
+{
+    type_register_static(&info);
+}
+
+type_init(register_types);
+
+static bool do_handshake(CharBackend *sock, Object *key, const char *sock_name,
+                         Error **errp)
+{
+    VMIntrospection_handshake send, recv;
+    size_t sz = sizeof(send);
+
+    /* TODO: do the cookie dance */
+
+    send.struct_size = sz;
+    memcpy(&send.uuid, &qemu_uuid, sizeof(send.uuid));
+
+    if (qemu_chr_fe_write_all(sock, (uint8_t *)&send, sz) != sz) {
+        error_setg(errp, "error writing to '%s': %d", sock_name, errno);
+        return false;
+    }
+
+    if (qemu_chr_fe_read_all(sock, (uint8_t *)&recv, sz) != sz) {
+        error_setg(errp, "error reading from '%s': %d", sock_name, errno);
+        return false;
+    }
+
+    if (memcmp(&send, &recv, sz)) {
+        error_setg(errp, "handshake failed");
+        return false;
+    }
+
+    return true;
+}
+
+int vm_introspection_fd(Object *obj, uint32_t *commands, uint32_t *events,
+                        Error **errp)
+{
+    VMIntrospection *i = VM_INTROSPECTION(obj);
+    Chardev *chr;
+    CharBackend sock;
+    Object *key;
+    int fd = -1;
+
+    /* TODO: proper handling of allow,deny props */
+    *commands = *events = -1;
+
+    key = object_resolve_path_component(object_get_objects_root(), i->keyid);
+    if (!key) {
+        error_setg(errp, "No secret object with id '%s'", i->keyid);
+        return -1;
+    }
+
+    chr = qemu_chr_find(i->chardevid);
+    if (chr == NULL) {
+        error_setg(errp, "Device '%s' not found", i->chardevid);
+        return -1;
+    }
+
+    if (!qemu_chr_fe_init(&sock, chr, &error_abort)) {
+        error_setg(errp, "Device '%s' not initialized", i->chardevid);
+        return -1;
+    }
+
+    if (do_handshake(&sock, key, i->chardevid, errp)) {
+        fd = object_property_get_int(OBJECT(chr), "fd", errp);
+        if (fd != -1) {
+            fd = dup(fd);
+        } else {
+            error_setg(errp, "no file handle from '%s': %d", i->chardevid,
+                       errno);
+        }
+    }
+
+    qemu_chr_fe_deinit(&sock, true);
+
+    return fd;
+}
diff --git a/chardev/char-socket.c b/chardev/char-socket.c
index 53eda8ef00..bcc69904e8 100644
--- a/chardev/char-socket.c
+++ b/chardev/char-socket.c
@@ -981,6 +981,7 @@ static void qemu_chr_parse_socket(QemuOpts *opts, ChardevBackend *backend,
     bool is_tn3270      = qemu_opt_get_bool(opts, "tn3270", false);
     bool do_nodelay     = !qemu_opt_get_bool(opts, "delay", true);
     int64_t reconnect   = qemu_opt_get_number(opts, "reconnect", 0);
+    const char *cid  = qemu_opt_get(opts, "cid");
     const char *path = qemu_opt_get(opts, "path");
     const char *host = qemu_opt_get(opts, "host");
     const char *port = qemu_opt_get(opts, "port");
@@ -990,8 +991,8 @@ static void qemu_chr_parse_socket(QemuOpts *opts, ChardevBackend *backend,
 
     backend->type = CHARDEV_BACKEND_KIND_SOCKET;
     if (!path) {
-        if (!host) {
-            error_setg(errp, "chardev: socket: no host given");
+        if (!host && !cid) {
+            error_setg(errp, "chardev: socket: no %s given", host ? "cid" : "host");
             return;
         }
         if (!port) {
@@ -1028,6 +1029,13 @@ static void qemu_chr_parse_socket(QemuOpts *opts, ChardevBackend *backend,
         addr->type = SOCKET_ADDRESS_LEGACY_KIND_UNIX;
         q_unix = addr->u.q_unix.data = g_new0(UnixSocketAddress, 1);
         q_unix->path = g_strdup(path);
+    } else if (cid) {
+        addr->type = SOCKET_ADDRESS_LEGACY_KIND_VSOCK;
+        addr->u.vsock.data = g_new0(VsockSocketAddress, 1);
+        *addr->u.vsock.data = (VsockSocketAddress) {
+            .cid  = g_strdup(cid),
+            .port = g_strdup(port),
+        };
     } else {
         addr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;
         addr->u.inet.data = g_new(InetSocketAddress, 1);
@@ -1062,6 +1070,21 @@ char_socket_get_connected(Object *obj, Error **errp)
     return s->connected;
 }
 
+static void
+char_socket_get_fd(Object *obj, Visitor *v, const char *name, void *opaque,
+                   Error **errp)
+{
+    int fd = -1;
+    SocketChardev *s = SOCKET_CHARDEV(obj);
+    QIOChannelSocket *sock = QIO_CHANNEL_SOCKET(s->sioc);
+
+    if (sock) {
+        fd = sock->fd;
+    }
+
+    visit_type_int32(v, name, &fd, errp);
+}
+
 static void char_socket_class_init(ObjectClass *oc, void *data)
 {
     ChardevClass *cc = CHARDEV_CLASS(oc);
@@ -1084,6 +1107,9 @@ static void char_socket_class_init(ObjectClass *oc, void *data)
 
     object_class_property_add_bool(oc, "connected", char_socket_get_connected,
                                    NULL, &error_abort);
+
+    object_class_property_add(oc, "fd", "int32", char_socket_get_fd,
+                              NULL, NULL, NULL, &error_abort);
 }
 
 static const TypeInfo char_socket_type_info = {
diff --git a/chardev/char.c b/chardev/char.c
index 2ae4f465ec..d9c4d54cf9 100644
--- a/chardev/char.c
+++ b/chardev/char.c
@@ -795,6 +795,9 @@ QemuOptsList qemu_chardev_opts = {
         },{
             .name = "host",
             .type = QEMU_OPT_STRING,
+        },{
+            .name = "cid",
+            .type = QEMU_OPT_STRING,
         },{
             .name = "port",
             .type = QEMU_OPT_STRING,
diff --git a/cpus.c b/cpus.c
index 114c29b6a0..02503809fe 100644
--- a/cpus.c
+++ b/cpus.c
@@ -51,6 +51,7 @@
 #include "hw/nmi.h"
 #include "sysemu/replay.h"
 #include "hw/boards.h"
+#include "qemu/cutils.h"
 
 #ifdef CONFIG_LINUX
 
diff --git a/include/sysemu/kvm.h b/include/sysemu/kvm.h
index bbf12a1723..8fe539a32b 100644
--- a/include/sysemu/kvm.h
+++ b/include/sysemu/kvm.h
@@ -531,4 +531,11 @@ int kvm_set_one_reg(CPUState *cs, uint64_t id, void *source);
 int kvm_get_one_reg(CPUState *cs, uint64_t id, void *target);
 struct ppc_radix_page_info *kvm_get_radix_page_info(void);
 int kvm_get_max_memslots(void);
+
+/**
+ * kvm_configure:
+ * @opts: accel properties
+ * @errp: error object handle
+ */
+void kvm_configure(QemuOpts *opts, Error **errp);
 #endif
diff --git a/include/sysemu/vm-introspection.h b/include/sysemu/vm-introspection.h
new file mode 100644
index 0000000000..c0175038f1
--- /dev/null
+++ b/include/sysemu/vm-introspection.h
@@ -0,0 +1,53 @@
+/*
+ * VM Introspection
+ *
+ * Copyright (C) 2017 Bitdefender S.R.L.
+ *
+ * This work is licensed under the terms of the GNU GPL, version 2 or later.
+ * See the COPYING file in the top-level directory.
+ */
+
+#ifndef VM_INTROSPECTION_H
+#define VM_INTROSPECTION_H
+
+/**
+ * VMIntrospection:
+ *
+ * The VMIntrospection object is used to do the handshake with an
+ * introspection tool and pass the connection to KVM.
+ *
+ *  $QEMU -chardev socket,id=chardev0,type=vsock,cid=10,port=1234           \
+ *        -object secret,id=key0,data=some                                  \
+ *        -object introspection,id=kvmi,chardev=chardev0,key=key0,allow=all \
+ *        -accel kvm,introspection=kvmi
+ *
+ */
+
+/**
+ * VMIntrospection_handshake:
+ *
+ * This structure is passed to the introspection tool during the handshake.
+ *
+ * @struct_size: the structure size (in case we extend it)
+ * @uuid: the UUID (the introspector may apply different settings based on this)
+ */
+typedef struct VMIntrospection_handshake {
+    uint32_t struct_size;
+    QemuUUID uuid;
+    /* ... */
+} VMIntrospection_handshake;
+
+/**
+ * vm_introspection_fd:
+ * @obj: the introspection object
+ * @commands: allowed commands mask
+ * @events: allowed events mask
+ * @errp: error object handle
+ *
+ * Returns: the file handle on success or -1 on failure.
+ */
+extern int vm_introspection_fd(Object *obj, uint32_t *commands,
+                               uint32_t *events, Error **errp);
+
+#endif
+
diff --git a/linux-headers/linux/kvm.h b/linux-headers/linux/kvm.h
index dd8a91801e..bda3db344a 100644
--- a/linux-headers/linux/kvm.h
+++ b/linux-headers/linux/kvm.h
@@ -1357,6 +1357,14 @@ struct kvm_s390_ucas_mapping {
 #define KVM_S390_GET_CMMA_BITS      _IOWR(KVMIO, 0xb8, struct kvm_s390_cmma_log)
 #define KVM_S390_SET_CMMA_BITS      _IOW(KVMIO, 0xb9, struct kvm_s390_cmma_log)
 
+struct kvm_introspection {
+        int fd;
+        __u32 padding;
+        __u32 commands;
+        __u32 events;
+};
+#define KVM_INTROSPECTION      _IOW(KVMIO, 0xff, struct kvm_introspection)
+
 #define KVM_DEV_ASSIGN_ENABLE_IOMMU	(1 << 0)
 #define KVM_DEV_ASSIGN_PCI_2_3		(1 << 1)
 #define KVM_DEV_ASSIGN_MASK_INTX	(1 << 2)
diff --git a/vl.c b/vl.c
index 1ad1c04637..c3f00476af 100644
--- a/vl.c
+++ b/vl.c
@@ -335,6 +335,11 @@ static QemuOptsList qemu_accel_opts = {
             .type = QEMU_OPT_STRING,
             .help = "Enable/disable multi-threaded TCG",
         },
+        {
+            .name = "introspection",
+            .type = QEMU_OPT_STRING,
+            .help = "Introspector tool",
+        },
         { /* end of list */ }
     },
 };
@@ -4619,6 +4624,10 @@ int main(int argc, char **argv, char **envp)
         qemu_tcg_configure(accel_opts, &error_fatal);
     }
 
+    if (kvm_enabled()) {
+        kvm_configure(accel_opts, &error_fatal);
+    }
+
     if (default_net) {
         QemuOptsList *net = qemu_find_opts("net");
         qemu_opts_set(net, NULL, "type", "nic", &error_abort);
-- 
2.14.2

